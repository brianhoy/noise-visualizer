{"version":3,"sources":["webpack:///webpack/bootstrap c6af69ab3b60999b3a45","webpack:///./src/workers/ChunkGenerator.worker.ts","webpack:///./src/components/webgl-view/procedural-generation/ChunkGenerator.ts","webpack:///./src/models/Chunk.ts"],"names":[],"mappings":"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","file":"c6af69ab3b60999b3a45.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c6af69ab3b60999b3a45\n **/","import {Chunk} from \"../models/Chunk\";\r\nimport {ChunkGenerator} from '../components/webgl-view/procedural-generation/ChunkGenerator';\r\n\r\ndeclare var self: any;\r\ndeclare var SimplexNoise: any;\r\n\r\nself.importScripts('public/scripts/vendor/three.min.js', 'public/scripts/vendor/simplex.js');\r\n\r\nclass ChunkGeneratorWorker {\r\n\tprivate chunkGenerator: ChunkGenerator;\r\n\r\n\tconstructor() {\r\n\t\tthis.chunkGenerator = new ChunkGenerator(1000, 10, null);\r\n\r\n\t\tself.onmessage = (event: MessageEvent) => {\r\n\t\t\tswitch(event.data.type) {\r\n\t\t\t\tcase \"generateChunks\":\r\n\t\t\t\t\tlet chunks = this.generateChunks(event.data.data);\r\n\t\t\t\t\t//postMessage(chunks);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"setGeneratorSettings\":\r\n\t\t\t\t\tlet chunkSize = event.data.data.chunkSize;\r\n\t\t\t\t\tthis.chunkGenerator.chunkSize = chunkSize;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic generateChunks(chunkCoords: THREE.Vector2[]): Array<{coords: Array<number>, geometryData: {vertices: Float32Array, normal: Float32Array, uvs: Float32Array, indices: Uint32Array}}> {\r\n\t\tlet chunks = new Array<{coords: Array<number>, geometryData: {vertices: Float32Array, normal: Float32Array, uvs: Float32Array, indices: Uint32Array}}>();\r\n\t\tfor(let chunkCoord of chunkCoords) {\r\n\t\t\tlet geometryData = this.chunkGenerator.generateChunkGeometryData(chunkCoord);\r\n\t\t\tchunks.push({coords: [chunkCoord.x, chunkCoord.y], geometryData: geometryData});\r\n\t\t}\r\n\t\treturn chunks;\r\n\t}\r\n}\r\nlet chunkGeneratorWorker: ChunkGeneratorWorker = new ChunkGeneratorWorker();\r\nconsole.log(\"ChunkGenerator.worker loaded\");\r\n\r\n// Main thread will send terrain to be generated periodically\r\n// If new terrain is sent while the worker is still working on the last set of terrain, \r\n// send over what's completed and start working on the new set\r\n\r\n\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/angular2-template-loader!./src/workers/ChunkGenerator.worker.ts\n **/","/// <reference path=\"../../../../typings/threejs/three.d.ts\"/>\r\n\r\ndeclare var SimplexNoise: any;\r\n\r\nimport {GetTerrainVertexShader} from \"../../shaders/TerrainShader_Vertex.glsl\"\r\nimport {GetTerrainFragmentShader} from \"../../shaders/TerrainShader_Fragment.glsl\"\r\nimport {AddShaderChunks} from \"../../shaders/ShaderChunks\";\r\nimport {Noise} from \"./Noise\";\r\nimport {Chunk} from \"../../../models/Chunk\";\r\n\r\nexport class ChunkGenerator {\r\n\tprivate mountainNoiseGenerator: Noise;\r\n\tprivate mountainMultiplierNoiseGenerator: any;\r\n\tprivate textureLoader: THREE.TextureLoader;\r\n\tprivate grassTexture: THREE.Texture;\r\n\tprivate shaders: any;\r\n\r\n\tprivate renderedGroundMaterial: THREE.Material;\r\n\tprivate renderedSegments: number;\r\n\r\n\tprivate groundMaterial: THREE.Material;\r\n\r\n\tconstructor(public chunkSize: number, public segments: number, private noiseGenerator: Noise) {\r\n\t\tthis.groundMaterial = new THREE.MeshLambertMaterial();\r\n\r\n\t\t//this.noiseGenerator = this.noiseGenerator ? this.noiseGenerator : new SimplexNoise();\r\n\r\n\t\t/*\r\n\t\tAddShaderChunks();\r\n\r\n\t\tthis.textureLoader = textureLoader || new THREE.TextureLoader();\r\n\t\tthis.noiseGenerator = new SimplexNoise();\r\n\t\tthis.mountainNoiseGenerator = new Noise();\r\n\t\tthis.mountainMultiplierNoiseGenerator = new SimplexNoise();\r\n\t\tthis.shaders =  { terrainLambert : THREE.ShaderLib[ 'lambert' ] };\r\n\t\tthis.segments = 5;\r\n\t\tthis.renderedSegments = 100;\r\n\r\n\t\tlet myProperties = {\r\n\t\t\tlights: true,\r\n\t\t\tfog: true,\r\n\t\t\ttransparent: true,\r\n\t\t\tcolor: new THREE.Color(10, 150, 20),\r\n\t\t\tmap: null // this.grassTexture || THREE.ImageUtils.loadTexture( 'images/grass.png' )\r\n\t\t};\r\n\r\n\t\tlet myUniforms = {\r\n\t\t\topacity: { type: \"f\", value: 0.4 },\r\n\t\t\tcolor: new THREE.Vector3(255, 100, 0),\r\n\t\t\ttime: { value: 1.0 }\r\n\t\t};\r\n\r\n\t\tthis.renderedGroundMaterial = this.terrainLambertMaterial(myProperties, myUniforms);\r\n\t}\r\n\r\n\tprivate terrainLambertMaterial(parameters, uniforms_) {\r\n\r\n\t\tvar material = new THREE.ShaderMaterial( {\r\n\t\t\tvertexShader: GetTerrainVertexShader(),\r\n\t\t\tfragmentShader: GetTerrainFragmentShader(),\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [ \r\n\t\t\t\tuniforms_, \r\n\t\t\t\tTHREE.ShaderLib[ 'lambert' ].uniforms ] ),\r\n\t\t\tlights: true\r\n\t\t} );\r\n\r\n\t\tmaterial.setValues( parameters )\r\n\r\n\t\treturn material; */\r\n\t}\r\n\r\n\tprivate tempVertex: number;\r\n\r\n\t/*public generateChunk(chunkCoords: THREE.Vector2): Chunk {\r\n\t\tlet realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\r\n\t\tlet material = new THREE.MeshLambertMaterial();\r\n\r\n\t\tlet geometry = new THREE.PlaneGeometry(this.chunkSize, this.chunkSize, this.segments, this.segments);\r\n\t\t//geometry.translate(this.chunkSize / 2, this.chunkSize / 2, 0)\r\n\r\n\t\tfor ( var i = 0; i < geometry.vertices.length; i++ ) {\r\n\t\t\tvar vertex = geometry.vertices[i];\r\n\t\t\tlet noiseCoords = new THREE.Vector2((realCoords.x + vertex.x)/5000, (-realCoords.z + vertex.y)/5000);\r\n\t\t\tvertex.z = this.noiseGenerator.noise(noiseCoords.x, noiseCoords.y) * 1000;\r\n\t\t}\r\n\t\tgeometry.computeFaceNormals();\r\n\t\tgeometry.computeVertexNormals();\r\n\r\n\t\tlet mesh = new THREE.Mesh(geometry, material);\r\n\t\tmesh.rotation.x = Math.PI / -2;\r\n\t\tmesh.receiveShadow = true;\r\n\t\tmesh.translateX(realCoords.x);\r\n\t\tmesh.translateY(-realCoords.z);\r\n\t\treturn new Chunk(mesh);\r\n\t} */\r\n\r\n\tpublic generateChunk(chunkCoords: THREE.Vector2): Chunk {\r\n\t\tlet realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\t\tlet geometry = new THREE.PlaneBufferGeometry(this.chunkSize, this.chunkSize, this.segments, this.segments);\r\n\t\tlet vertices = geometry.attributes.position.array;\r\n\t\tfor(let i = 2; i < vertices.length; i += 3) {\r\n\t\t\tlet noiseCoords = new THREE.Vector2((realCoords.x + vertices[i - 2])/5000, (-realCoords.z + vertices[i - 1])/5000);\r\n\t\t\tvertices[i] += this.noiseGenerator.noise(noiseCoords.x, noiseCoords.y);\r\n\t\t}\r\n\t\tconsole.log(\"vertices[1] = \", vertices[1]);\r\n\t\tgeometry.computeVertexNormals();\r\n\r\n\t\tgeometry.rotateX( -Math.PI/2);\r\n\t\tgeometry.translate(realCoords.x, 0, realCoords.z);\r\n\t\tlet mesh = new THREE.Mesh(geometry, this.groundMaterial);\r\n\t\tmesh.receiveShadow = true;\r\n\t\treturn new Chunk(mesh, chunkCoords);\r\n\t}\r\n\r\n\tpublic generateChunkGeometryData(chunkCoords: THREE.Vector2): {vertices: Float32Array, normal: Float32Array, uvs: Float32Array, indices: Uint32Array} {\r\n\t\tlet geometryData: any = {};\r\n\r\n\t\tlet realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\t\tlet geometry = new THREE.PlaneBufferGeometry(this.chunkSize, this.chunkSize, this.segments, this.segments);\r\n\t\tgeometryData.vertices = geometry.attributes.position.array;\r\n\t\tgeometryData.normal = geometry.attributes.normal.array;\r\n\t\tgeometryData.uv = geometry.attributes.uv.array;\r\n\t\tgeometryData.indices = geometry.getIndex().array;\r\n\t\tfor(let i = 2; i < geometryData.vertices.length; i += 3) {\r\n\t\t\tlet noiseCoords = new THREE.Vector2((realCoords.x + geometryData.vertices[i - 2])/5000, (-realCoords.z + geometryData.vertices[i - 1])/5000);\r\n\t\t\tgeometryData.vertices[i] += this.noiseGenerator.noise(noiseCoords.x, + noiseCoords.y) * 1000;\r\n\t\t}\r\n\t\treturn geometryData;\r\n\t}\r\n\r\n\tpublic generateChunkFromGeometryData(chunkCoords: THREE.Vector2, geometryData: {vertices: Float32Array, normal: Float32Array, uvs: Float32Array, indices: Uint32Array}): Chunk {\r\n\t\t\tlet realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\r\n\t\t\tlet geometry = new THREE.BufferGeometry(); \r\n\t\t\tgeometry.setIndex( new THREE.BufferAttribute( geometryData.indices, 1 ) );\r\n\t\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute(geometryData.vertices, 3));\r\n\t\t\tgeometry.addAttribute('normal', new THREE.BufferAttribute(geometryData.normal, 3));\r\n\t\t\tgeometry.addAttribute('uv', new THREE.BufferAttribute(geometryData.uvs, 2));\r\n\t\t\t\r\n\r\n\t\t\tgeometry.computeVertexNormals();\r\n\t\t\tgeometry.rotateX( -Math.PI/2);\r\n\t\t\tgeometry.translate(realCoords.x, 0, realCoords.z);\r\n\r\n\t\t\tlet mesh = new THREE.Mesh(geometry, this.groundMaterial);\r\n\t\t\tmesh.receiveShadow = true;\r\n\r\n\t\t\tlet chunk = new Chunk(mesh, chunkCoords);\r\n\t\t\treturn chunk;\r\n\t}\r\n\r\n\tpublic setChunkSize(newChunkSize: number) {\r\n\t\tthis.chunkSize = newChunkSize;\r\n\t}\r\n\r\n\tpublic setSegments(newSegments: number) {\r\n\t\tthis.segments = newSegments;\r\n\t}\r\n\r\n\tpublic setNoiseGenerator(newNoise: Noise) {\r\n\t\tthis.noiseGenerator = newNoise;\r\n\t}\r\n\r\n\tprivate fastSigmoid(x: number): number {\r\n\t\treturn x / (1 + Math.abs(x));\r\n\t}\r\n\r\n\t/*private worleyNoise(xCoordinate: number, yCoordinate: number, scale: number) {\r\n\t\tfunction cos(angle) {\r\n\t\t\t\tif (angle.length) return angle.map(cos);\r\n\t\t\t\treturn Math.cos(angle);\r\n\t\t}\r\n\t\tfunction fract(x) {\r\n\t\t\t\tif (x.length) return x.map(fract);\r\n\t\t\t\treturn x - Math.floor(x);\r\n\t\t}\r\n\t\tfunction floor(x) {\r\n\t\t\t\tif (x.length) return x.map(floor);\r\n\t\t\t\treturn Math.floor(x);\r\n\t\t}\r\n\t\tfunction vec2(x, y) {\r\n\t\t\t\tif (x == null) x = 0;\r\n\t\t\t\tif (y == null) y = x;\r\n\t\t\t\treturn [x, y]\r\n\t\t}\r\n\t\tvec2.add = function anonymous(out,a,b) {\r\n\t\t\tout[0] = a[0] + b[0];\r\n\t\t\tout[1] = a[1] + b[1]\r\n\t\t\treturn out;\r\n\t\t}\r\n\t\tfunction length(x) {\r\n\t\t\t\tvar sum = 0;\r\n\t\t\t\tfor (var i = 0; i < x.length; i++) {\r\n\t\t\t\t\t\tsum += x[i]*x[i];\r\n\t\t\t\t}\r\n\t\t\t\treturn Math.sqrt(sum);\r\n\t\t}\r\n\t\tfunction r (n) {\r\n\t\t\t\treturn fract(cos(n * 89.42) * 343.42);\r\n\t\t};\r\n\t\tfunction r_vec2 (n) {\r\n\t\t\t\treturn [r(n[0] * 23.62 - 300.0 + n[1] * 34.35), r(n[0] * 45.13 + 256.0 + n[1] * 38.89)];\r\n\t\t};\r\n\t\tfunction worley (n, s) {\r\n\t\t\t\tvar dis = 2.0;\r\n\t\t\t\tfor (var x = -1; x <= 1; x++) {\r\n\t\t\t\t\tfor (var y = -1; y <= 1; y++) {\r\n\t\t\t\t\t\tvar p = vec2.add([], floor([n[0] / s, n[1] / s]), [x, y]);\r\n\t\t\t\t\t\tvar d = length([r_vec2(p)[0] + x - fract([n[0] / s, n[1] / s])[0], r_vec2(p)[1] + y - fract([n[0] / s, n[1] / s])[1]]);\r\n\t\t\t\t\t\tif (dis > d) {\r\n\t\t\t\t\t\tdis = d;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t};\r\n\t\t\t\t};\r\n\t\t\t\treturn 1.0 - dis;\r\n\t\t};\r\n\t\treturn worley([xCoordinate, yCoordinate], scale)\r\n\t} */\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/angular2-template-loader!./src/components/webgl-view/procedural-generation/ChunkGenerator.ts\n **/","export class Chunk {\r\n\tconstructor(public mesh: THREE.Mesh, \r\n\t\tpublic chunkCoordinates: THREE.Vector2) {}\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/angular2-template-loader!./src/models/Chunk.ts\n **/"],"sourceRoot":""}