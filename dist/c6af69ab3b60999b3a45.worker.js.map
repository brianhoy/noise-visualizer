{"version":3,"sources":["webpack:///c6af69ab3b60999b3a45.worker.js","webpack:///webpack/bootstrap c6af69ab3b60999b3a45","webpack:///./src/workers/ChunkGenerator.worker.ts","webpack:///./src/components/webgl-view/procedural-generation/ChunkGenerator.ts","webpack:///./src/models/Chunk.ts"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","ChunkGenerator_1","self","importScripts","ChunkGeneratorWorker","_this","this","chunkGenerator","ChunkGenerator","onmessage","event","data","type","generateChunks","chunkSize","prototype","chunkCoords","chunks","Array","_i","chunkCoords_1","length","chunkCoord","geometryData","generateChunkGeometryData","push","coords","x","y","console","log","Chunk_1","segments","noiseGenerator","groundMaterial","THREE","MeshLambertMaterial","generateChunk","realCoords","Vector3","geometry","PlaneBufferGeometry","vertices","attributes","position","array","i","noiseCoords","Vector2","z","noise","computeVertexNormals","rotateX","Math","PI","translate","mesh","Mesh","receiveShadow","Chunk","normal","uv","indices","getIndex","generateChunkFromGeometryData","BufferGeometry","setIndex","BufferAttribute","addAttribute","uvs","chunk","setChunkSize","newChunkSize","setSegments","newSegments","setNoiseGenerator","newNoise","fastSigmoid","abs","chunkCoordinates"],"mappings":"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","file":"c6af69ab3b60999b3a45.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar ChunkGenerator_1 = __webpack_require__(1);\r\n\tself.importScripts('public/scripts/vendor/three.min.js', 'public/scripts/vendor/simplex.js');\r\n\tvar ChunkGeneratorWorker = (function () {\r\n\t    function ChunkGeneratorWorker() {\r\n\t        var _this = this;\r\n\t        this.chunkGenerator = new ChunkGenerator_1.ChunkGenerator(1000, 10, null);\r\n\t        self.onmessage = function (event) {\r\n\t            switch (event.data.type) {\r\n\t                case \"generateChunks\":\r\n\t                    var chunks = _this.generateChunks(event.data.data);\r\n\t                    //postMessage(chunks);\r\n\t                    break;\r\n\t                case \"setGeneratorSettings\":\r\n\t                    var chunkSize = event.data.data.chunkSize;\r\n\t                    _this.chunkGenerator.chunkSize = chunkSize;\r\n\t            }\r\n\t        };\r\n\t    }\r\n\t    ChunkGeneratorWorker.prototype.generateChunks = function (chunkCoords) {\r\n\t        var chunks = new Array();\r\n\t        for (var _i = 0, chunkCoords_1 = chunkCoords; _i < chunkCoords_1.length; _i++) {\r\n\t            var chunkCoord = chunkCoords_1[_i];\r\n\t            var geometryData = this.chunkGenerator.generateChunkGeometryData(chunkCoord);\r\n\t            chunks.push({ coords: [chunkCoord.x, chunkCoord.y], geometryData: geometryData });\r\n\t        }\r\n\t        return chunks;\r\n\t    };\r\n\t    return ChunkGeneratorWorker;\r\n\t}());\r\n\tvar chunkGeneratorWorker = new ChunkGeneratorWorker();\r\n\tconsole.log(\"ChunkGenerator.worker loaded\");\r\n\t// Main thread will send terrain to be generated periodically\r\n\t// If new terrain is sent while the worker is still working on the last set of terrain, \r\n\t// send over what's completed and start working on the new set\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/// <reference path=\"../../../../typings/threejs/three.d.ts\"/>\r\n\t\"use strict\";\r\n\tvar Chunk_1 = __webpack_require__(2);\r\n\tvar ChunkGenerator = (function () {\r\n\t    function ChunkGenerator(chunkSize, segments, noiseGenerator) {\r\n\t        this.chunkSize = chunkSize;\r\n\t        this.segments = segments;\r\n\t        this.noiseGenerator = noiseGenerator;\r\n\t        this.groundMaterial = new THREE.MeshLambertMaterial();\r\n\t        //this.noiseGenerator = this.noiseGenerator ? this.noiseGenerator : new SimplexNoise();\r\n\t        /*\r\n\t        AddShaderChunks();\r\n\t\r\n\t        this.textureLoader = textureLoader || new THREE.TextureLoader();\r\n\t        this.noiseGenerator = new SimplexNoise();\r\n\t        this.mountainNoiseGenerator = new Noise();\r\n\t        this.mountainMultiplierNoiseGenerator = new SimplexNoise();\r\n\t        this.shaders =  { terrainLambert : THREE.ShaderLib[ 'lambert' ] };\r\n\t        this.segments = 5;\r\n\t        this.renderedSegments = 100;\r\n\t\r\n\t        let myProperties = {\r\n\t            lights: true,\r\n\t            fog: true,\r\n\t            transparent: true,\r\n\t            color: new THREE.Color(10, 150, 20),\r\n\t            map: null // this.grassTexture || THREE.ImageUtils.loadTexture( 'images/grass.png' )\r\n\t        };\r\n\t\r\n\t        let myUniforms = {\r\n\t            opacity: { type: \"f\", value: 0.4 },\r\n\t            color: new THREE.Vector3(255, 100, 0),\r\n\t            time: { value: 1.0 }\r\n\t        };\r\n\t\r\n\t        this.renderedGroundMaterial = this.terrainLambertMaterial(myProperties, myUniforms);\r\n\t    }\r\n\t\r\n\t    private terrainLambertMaterial(parameters, uniforms_) {\r\n\t\r\n\t        var material = new THREE.ShaderMaterial( {\r\n\t            vertexShader: GetTerrainVertexShader(),\r\n\t            fragmentShader: GetTerrainFragmentShader(),\r\n\t            uniforms: THREE.UniformsUtils.merge( [\r\n\t                uniforms_,\r\n\t                THREE.ShaderLib[ 'lambert' ].uniforms ] ),\r\n\t            lights: true\r\n\t        } );\r\n\t\r\n\t        material.setValues( parameters )\r\n\t\r\n\t        return material; */\r\n\t    }\r\n\t    /*public generateChunk(chunkCoords: THREE.Vector2): Chunk {\r\n\t        let realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\t\r\n\t        let material = new THREE.MeshLambertMaterial();\r\n\t\r\n\t        let geometry = new THREE.PlaneGeometry(this.chunkSize, this.chunkSize, this.segments, this.segments);\r\n\t        //geometry.translate(this.chunkSize / 2, this.chunkSize / 2, 0)\r\n\t\r\n\t        for ( var i = 0; i < geometry.vertices.length; i++ ) {\r\n\t            var vertex = geometry.vertices[i];\r\n\t            let noiseCoords = new THREE.Vector2((realCoords.x + vertex.x)/5000, (-realCoords.z + vertex.y)/5000);\r\n\t            vertex.z = this.noiseGenerator.noise(noiseCoords.x, noiseCoords.y) * 1000;\r\n\t        }\r\n\t        geometry.computeFaceNormals();\r\n\t        geometry.computeVertexNormals();\r\n\t\r\n\t        let mesh = new THREE.Mesh(geometry, material);\r\n\t        mesh.rotation.x = Math.PI / -2;\r\n\t        mesh.receiveShadow = true;\r\n\t        mesh.translateX(realCoords.x);\r\n\t        mesh.translateY(-realCoords.z);\r\n\t        return new Chunk(mesh);\r\n\t    } */\r\n\t    ChunkGenerator.prototype.generateChunk = function (chunkCoords) {\r\n\t        var realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\t        var geometry = new THREE.PlaneBufferGeometry(this.chunkSize, this.chunkSize, this.segments, this.segments);\r\n\t        var vertices = geometry.attributes.position.array;\r\n\t        for (var i = 2; i < vertices.length; i += 3) {\r\n\t            var noiseCoords = new THREE.Vector2((realCoords.x + vertices[i - 2]) / 5000, (-realCoords.z + vertices[i - 1]) / 5000);\r\n\t            vertices[i] += this.noiseGenerator.noise(noiseCoords.x, noiseCoords.y);\r\n\t        }\r\n\t        console.log(\"vertices[1] = \", vertices[1]);\r\n\t        geometry.computeVertexNormals();\r\n\t        geometry.rotateX(-Math.PI / 2);\r\n\t        geometry.translate(realCoords.x, 0, realCoords.z);\r\n\t        var mesh = new THREE.Mesh(geometry, this.groundMaterial);\r\n\t        mesh.receiveShadow = true;\r\n\t        return new Chunk_1.Chunk(mesh, chunkCoords);\r\n\t    };\r\n\t    ChunkGenerator.prototype.generateChunkGeometryData = function (chunkCoords) {\r\n\t        var geometryData = {};\r\n\t        var realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\t        var geometry = new THREE.PlaneBufferGeometry(this.chunkSize, this.chunkSize, this.segments, this.segments);\r\n\t        geometryData.vertices = geometry.attributes.position.array;\r\n\t        geometryData.normal = geometry.attributes.normal.array;\r\n\t        geometryData.uv = geometry.attributes.uv.array;\r\n\t        geometryData.indices = geometry.getIndex().array;\r\n\t        for (var i = 2; i < geometryData.vertices.length; i += 3) {\r\n\t            var noiseCoords = new THREE.Vector2((realCoords.x + geometryData.vertices[i - 2]) / 5000, (-realCoords.z + geometryData.vertices[i - 1]) / 5000);\r\n\t            geometryData.vertices[i] += this.noiseGenerator.noise(noiseCoords.x, +noiseCoords.y) * 1000;\r\n\t        }\r\n\t        return geometryData;\r\n\t    };\r\n\t    ChunkGenerator.prototype.generateChunkFromGeometryData = function (chunkCoords, geometryData) {\r\n\t        var realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\t        var geometry = new THREE.BufferGeometry();\r\n\t        geometry.setIndex(new THREE.BufferAttribute(geometryData.indices, 1));\r\n\t        geometry.addAttribute('position', new THREE.BufferAttribute(geometryData.vertices, 3));\r\n\t        geometry.addAttribute('normal', new THREE.BufferAttribute(geometryData.normal, 3));\r\n\t        geometry.addAttribute('uv', new THREE.BufferAttribute(geometryData.uvs, 2));\r\n\t        geometry.computeVertexNormals();\r\n\t        geometry.rotateX(-Math.PI / 2);\r\n\t        geometry.translate(realCoords.x, 0, realCoords.z);\r\n\t        var mesh = new THREE.Mesh(geometry, this.groundMaterial);\r\n\t        mesh.receiveShadow = true;\r\n\t        var chunk = new Chunk_1.Chunk(mesh, chunkCoords);\r\n\t        return chunk;\r\n\t    };\r\n\t    ChunkGenerator.prototype.setChunkSize = function (newChunkSize) {\r\n\t        this.chunkSize = newChunkSize;\r\n\t    };\r\n\t    ChunkGenerator.prototype.setSegments = function (newSegments) {\r\n\t        this.segments = newSegments;\r\n\t    };\r\n\t    ChunkGenerator.prototype.setNoiseGenerator = function (newNoise) {\r\n\t        this.noiseGenerator = newNoise;\r\n\t    };\r\n\t    ChunkGenerator.prototype.fastSigmoid = function (x) {\r\n\t        return x / (1 + Math.abs(x));\r\n\t    };\r\n\t    return ChunkGenerator;\r\n\t}());\r\n\texports.ChunkGenerator = ChunkGenerator;\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\tvar Chunk = (function () {\r\n\t    function Chunk(mesh, chunkCoordinates) {\r\n\t        this.mesh = mesh;\r\n\t        this.chunkCoordinates = chunkCoordinates;\r\n\t    }\r\n\t    return Chunk;\r\n\t}());\r\n\texports.Chunk = Chunk;\r\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** c6af69ab3b60999b3a45.worker.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c6af69ab3b60999b3a45\n **/","import {Chunk} from \"../models/Chunk\";\r\nimport {ChunkGenerator} from '../components/webgl-view/procedural-generation/ChunkGenerator';\r\n\r\ndeclare var self: any;\r\ndeclare var SimplexNoise: any;\r\n\r\nself.importScripts('public/scripts/vendor/three.min.js', 'public/scripts/vendor/simplex.js');\r\n\r\nclass ChunkGeneratorWorker {\r\n\tprivate chunkGenerator: ChunkGenerator;\r\n\r\n\tconstructor() {\r\n\t\tthis.chunkGenerator = new ChunkGenerator(1000, 10, null);\r\n\r\n\t\tself.onmessage = (event: MessageEvent) => {\r\n\t\t\tswitch(event.data.type) {\r\n\t\t\t\tcase \"generateChunks\":\r\n\t\t\t\t\tlet chunks = this.generateChunks(event.data.data);\r\n\t\t\t\t\t//postMessage(chunks);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"setGeneratorSettings\":\r\n\t\t\t\t\tlet chunkSize = event.data.data.chunkSize;\r\n\t\t\t\t\tthis.chunkGenerator.chunkSize = chunkSize;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic generateChunks(chunkCoords: THREE.Vector2[]): Array<{coords: Array<number>, geometryData: {vertices: Float32Array, normal: Float32Array, uvs: Float32Array, indices: Uint32Array}}> {\r\n\t\tlet chunks = new Array<{coords: Array<number>, geometryData: {vertices: Float32Array, normal: Float32Array, uvs: Float32Array, indices: Uint32Array}}>();\r\n\t\tfor(let chunkCoord of chunkCoords) {\r\n\t\t\tlet geometryData = this.chunkGenerator.generateChunkGeometryData(chunkCoord);\r\n\t\t\tchunks.push({coords: [chunkCoord.x, chunkCoord.y], geometryData: geometryData});\r\n\t\t}\r\n\t\treturn chunks;\r\n\t}\r\n}\r\nlet chunkGeneratorWorker: ChunkGeneratorWorker = new ChunkGeneratorWorker();\r\nconsole.log(\"ChunkGenerator.worker loaded\");\r\n\r\n// Main thread will send terrain to be generated periodically\r\n// If new terrain is sent while the worker is still working on the last set of terrain, \r\n// send over what's completed and start working on the new set\r\n\r\n\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/angular2-template-loader!./src/workers/ChunkGenerator.worker.ts\n **/","/// <reference path=\"../../../../typings/threejs/three.d.ts\"/>\r\n\r\ndeclare var SimplexNoise: any;\r\n\r\nimport {GetTerrainVertexShader} from \"../../shaders/TerrainShader_Vertex.glsl\"\r\nimport {GetTerrainFragmentShader} from \"../../shaders/TerrainShader_Fragment.glsl\"\r\nimport {AddShaderChunks} from \"../../shaders/ShaderChunks\";\r\nimport {Noise} from \"./Noise\";\r\nimport {Chunk} from \"../../../models/Chunk\";\r\n\r\nexport class ChunkGenerator {\r\n\tprivate mountainNoiseGenerator: Noise;\r\n\tprivate mountainMultiplierNoiseGenerator: any;\r\n\tprivate textureLoader: THREE.TextureLoader;\r\n\tprivate grassTexture: THREE.Texture;\r\n\tprivate shaders: any;\r\n\r\n\tprivate renderedGroundMaterial: THREE.Material;\r\n\tprivate renderedSegments: number;\r\n\r\n\tprivate groundMaterial: THREE.Material;\r\n\r\n\tconstructor(public chunkSize: number, public segments: number, private noiseGenerator: Noise) {\r\n\t\tthis.groundMaterial = new THREE.MeshLambertMaterial();\r\n\r\n\t\t//this.noiseGenerator = this.noiseGenerator ? this.noiseGenerator : new SimplexNoise();\r\n\r\n\t\t/*\r\n\t\tAddShaderChunks();\r\n\r\n\t\tthis.textureLoader = textureLoader || new THREE.TextureLoader();\r\n\t\tthis.noiseGenerator = new SimplexNoise();\r\n\t\tthis.mountainNoiseGenerator = new Noise();\r\n\t\tthis.mountainMultiplierNoiseGenerator = new SimplexNoise();\r\n\t\tthis.shaders =  { terrainLambert : THREE.ShaderLib[ 'lambert' ] };\r\n\t\tthis.segments = 5;\r\n\t\tthis.renderedSegments = 100;\r\n\r\n\t\tlet myProperties = {\r\n\t\t\tlights: true,\r\n\t\t\tfog: true,\r\n\t\t\ttransparent: true,\r\n\t\t\tcolor: new THREE.Color(10, 150, 20),\r\n\t\t\tmap: null // this.grassTexture || THREE.ImageUtils.loadTexture( 'images/grass.png' )\r\n\t\t};\r\n\r\n\t\tlet myUniforms = {\r\n\t\t\topacity: { type: \"f\", value: 0.4 },\r\n\t\t\tcolor: new THREE.Vector3(255, 100, 0),\r\n\t\t\ttime: { value: 1.0 }\r\n\t\t};\r\n\r\n\t\tthis.renderedGroundMaterial = this.terrainLambertMaterial(myProperties, myUniforms);\r\n\t}\r\n\r\n\tprivate terrainLambertMaterial(parameters, uniforms_) {\r\n\r\n\t\tvar material = new THREE.ShaderMaterial( {\r\n\t\t\tvertexShader: GetTerrainVertexShader(),\r\n\t\t\tfragmentShader: GetTerrainFragmentShader(),\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [ \r\n\t\t\t\tuniforms_, \r\n\t\t\t\tTHREE.ShaderLib[ 'lambert' ].uniforms ] ),\r\n\t\t\tlights: true\r\n\t\t} );\r\n\r\n\t\tmaterial.setValues( parameters )\r\n\r\n\t\treturn material; */\r\n\t}\r\n\r\n\tprivate tempVertex: number;\r\n\r\n\t/*public generateChunk(chunkCoords: THREE.Vector2): Chunk {\r\n\t\tlet realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\r\n\t\tlet material = new THREE.MeshLambertMaterial();\r\n\r\n\t\tlet geometry = new THREE.PlaneGeometry(this.chunkSize, this.chunkSize, this.segments, this.segments);\r\n\t\t//geometry.translate(this.chunkSize / 2, this.chunkSize / 2, 0)\r\n\r\n\t\tfor ( var i = 0; i < geometry.vertices.length; i++ ) {\r\n\t\t\tvar vertex = geometry.vertices[i];\r\n\t\t\tlet noiseCoords = new THREE.Vector2((realCoords.x + vertex.x)/5000, (-realCoords.z + vertex.y)/5000);\r\n\t\t\tvertex.z = this.noiseGenerator.noise(noiseCoords.x, noiseCoords.y) * 1000;\r\n\t\t}\r\n\t\tgeometry.computeFaceNormals();\r\n\t\tgeometry.computeVertexNormals();\r\n\r\n\t\tlet mesh = new THREE.Mesh(geometry, material);\r\n\t\tmesh.rotation.x = Math.PI / -2;\r\n\t\tmesh.receiveShadow = true;\r\n\t\tmesh.translateX(realCoords.x);\r\n\t\tmesh.translateY(-realCoords.z);\r\n\t\treturn new Chunk(mesh);\r\n\t} */\r\n\r\n\tpublic generateChunk(chunkCoords: THREE.Vector2): Chunk {\r\n\t\tlet realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\t\tlet geometry = new THREE.PlaneBufferGeometry(this.chunkSize, this.chunkSize, this.segments, this.segments);\r\n\t\tlet vertices = geometry.attributes.position.array;\r\n\t\tfor(let i = 2; i < vertices.length; i += 3) {\r\n\t\t\tlet noiseCoords = new THREE.Vector2((realCoords.x + vertices[i - 2])/5000, (-realCoords.z + vertices[i - 1])/5000);\r\n\t\t\tvertices[i] += this.noiseGenerator.noise(noiseCoords.x, noiseCoords.y);\r\n\t\t}\r\n\t\tconsole.log(\"vertices[1] = \", vertices[1]);\r\n\t\tgeometry.computeVertexNormals();\r\n\r\n\t\tgeometry.rotateX( -Math.PI/2);\r\n\t\tgeometry.translate(realCoords.x, 0, realCoords.z);\r\n\t\tlet mesh = new THREE.Mesh(geometry, this.groundMaterial);\r\n\t\tmesh.receiveShadow = true;\r\n\t\treturn new Chunk(mesh, chunkCoords);\r\n\t}\r\n\r\n\tpublic generateChunkGeometryData(chunkCoords: THREE.Vector2): {vertices: Float32Array, normal: Float32Array, uvs: Float32Array, indices: Uint32Array} {\r\n\t\tlet geometryData: any = {};\r\n\r\n\t\tlet realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\t\tlet geometry = new THREE.PlaneBufferGeometry(this.chunkSize, this.chunkSize, this.segments, this.segments);\r\n\t\tgeometryData.vertices = geometry.attributes.position.array;\r\n\t\tgeometryData.normal = geometry.attributes.normal.array;\r\n\t\tgeometryData.uv = geometry.attributes.uv.array;\r\n\t\tgeometryData.indices = geometry.getIndex().array;\r\n\t\tfor(let i = 2; i < geometryData.vertices.length; i += 3) {\r\n\t\t\tlet noiseCoords = new THREE.Vector2((realCoords.x + geometryData.vertices[i - 2])/5000, (-realCoords.z + geometryData.vertices[i - 1])/5000);\r\n\t\t\tgeometryData.vertices[i] += this.noiseGenerator.noise(noiseCoords.x, + noiseCoords.y) * 1000;\r\n\t\t}\r\n\t\treturn geometryData;\r\n\t}\r\n\r\n\tpublic generateChunkFromGeometryData(chunkCoords: THREE.Vector2, geometryData: {vertices: Float32Array, normal: Float32Array, uvs: Float32Array, indices: Uint32Array}): Chunk {\r\n\t\t\tlet realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\r\n\t\t\tlet geometry = new THREE.BufferGeometry(); \r\n\t\t\tgeometry.setIndex( new THREE.BufferAttribute( geometryData.indices, 1 ) );\r\n\t\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute(geometryData.vertices, 3));\r\n\t\t\tgeometry.addAttribute('normal', new THREE.BufferAttribute(geometryData.normal, 3));\r\n\t\t\tgeometry.addAttribute('uv', new THREE.BufferAttribute(geometryData.uvs, 2));\r\n\t\t\t\r\n\r\n\t\t\tgeometry.computeVertexNormals();\r\n\t\t\tgeometry.rotateX( -Math.PI/2);\r\n\t\t\tgeometry.translate(realCoords.x, 0, realCoords.z);\r\n\r\n\t\t\tlet mesh = new THREE.Mesh(geometry, this.groundMaterial);\r\n\t\t\tmesh.receiveShadow = true;\r\n\r\n\t\t\tlet chunk = new Chunk(mesh, chunkCoords);\r\n\t\t\treturn chunk;\r\n\t}\r\n\r\n\tpublic setChunkSize(newChunkSize: number) {\r\n\t\tthis.chunkSize = newChunkSize;\r\n\t}\r\n\r\n\tpublic setSegments(newSegments: number) {\r\n\t\tthis.segments = newSegments;\r\n\t}\r\n\r\n\tpublic setNoiseGenerator(newNoise: Noise) {\r\n\t\tthis.noiseGenerator = newNoise;\r\n\t}\r\n\r\n\tprivate fastSigmoid(x: number): number {\r\n\t\treturn x / (1 + Math.abs(x));\r\n\t}\r\n\r\n\t/*private worleyNoise(xCoordinate: number, yCoordinate: number, scale: number) {\r\n\t\tfunction cos(angle) {\r\n\t\t\t\tif (angle.length) return angle.map(cos);\r\n\t\t\t\treturn Math.cos(angle);\r\n\t\t}\r\n\t\tfunction fract(x) {\r\n\t\t\t\tif (x.length) return x.map(fract);\r\n\t\t\t\treturn x - Math.floor(x);\r\n\t\t}\r\n\t\tfunction floor(x) {\r\n\t\t\t\tif (x.length) return x.map(floor);\r\n\t\t\t\treturn Math.floor(x);\r\n\t\t}\r\n\t\tfunction vec2(x, y) {\r\n\t\t\t\tif (x == null) x = 0;\r\n\t\t\t\tif (y == null) y = x;\r\n\t\t\t\treturn [x, y]\r\n\t\t}\r\n\t\tvec2.add = function anonymous(out,a,b) {\r\n\t\t\tout[0] = a[0] + b[0];\r\n\t\t\tout[1] = a[1] + b[1]\r\n\t\t\treturn out;\r\n\t\t}\r\n\t\tfunction length(x) {\r\n\t\t\t\tvar sum = 0;\r\n\t\t\t\tfor (var i = 0; i < x.length; i++) {\r\n\t\t\t\t\t\tsum += x[i]*x[i];\r\n\t\t\t\t}\r\n\t\t\t\treturn Math.sqrt(sum);\r\n\t\t}\r\n\t\tfunction r (n) {\r\n\t\t\t\treturn fract(cos(n * 89.42) * 343.42);\r\n\t\t};\r\n\t\tfunction r_vec2 (n) {\r\n\t\t\t\treturn [r(n[0] * 23.62 - 300.0 + n[1] * 34.35), r(n[0] * 45.13 + 256.0 + n[1] * 38.89)];\r\n\t\t};\r\n\t\tfunction worley (n, s) {\r\n\t\t\t\tvar dis = 2.0;\r\n\t\t\t\tfor (var x = -1; x <= 1; x++) {\r\n\t\t\t\t\tfor (var y = -1; y <= 1; y++) {\r\n\t\t\t\t\t\tvar p = vec2.add([], floor([n[0] / s, n[1] / s]), [x, y]);\r\n\t\t\t\t\t\tvar d = length([r_vec2(p)[0] + x - fract([n[0] / s, n[1] / s])[0], r_vec2(p)[1] + y - fract([n[0] / s, n[1] / s])[1]]);\r\n\t\t\t\t\t\tif (dis > d) {\r\n\t\t\t\t\t\tdis = d;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t};\r\n\t\t\t\t};\r\n\t\t\t\treturn 1.0 - dis;\r\n\t\t};\r\n\t\treturn worley([xCoordinate, yCoordinate], scale)\r\n\t} */\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/angular2-template-loader!./src/components/webgl-view/procedural-generation/ChunkGenerator.ts\n **/","export class Chunk {\r\n\tconstructor(public mesh: THREE.Mesh, \r\n\t\tpublic chunkCoordinates: THREE.Vector2) {}\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/angular2-template-loader!./src/models/Chunk.ts\n **/"],"sourceRoot":""}