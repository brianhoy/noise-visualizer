{"version":3,"sources":["webpack:///c6af69ab3b60999b3a45.worker.js","webpack:///webpack/bootstrap c6af69ab3b60999b3a45","webpack:///./src/workers/ChunkGenerator.worker.ts","webpack:///./src/components/webgl-view/procedural-generation/ChunkGenerator.ts","webpack:///./src/models/Chunk.ts"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","ChunkGenerator_1","self","importScripts","ChunkGeneratorWorker","_this","this","chunkGenerator","ChunkGenerator","onmessage","event","data","type","generateChunks","chunkSize","prototype","chunkCoords","chunks","Array","_i","chunkCoords_1","length","chunkCoord","geometryData","generateChunkGeometryData","push","coords","x","y","console","log","Chunk_1","segments","noiseGenerator","groundMaterial","THREE","MeshLambertMaterial","generateChunk","realCoords","Vector3","geometry","PlaneBufferGeometry","vertices","attributes","position","array","i","noiseCoords","Vector2","z","noise","computeVertexNormals","rotateX","Math","PI","translate","mesh","Mesh","receiveShadow","Chunk","normal","uv","indices","getIndex","generateChunkFromGeometryData","BufferGeometry","setIndex","BufferAttribute","addAttribute","uvs","chunk","setChunkSize","newChunkSize","setSegments","newSegments","setNoiseGenerator","newNoise","fastSigmoid","abs","chunkCoordinates"],"mappings":"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","file":"c6af69ab3b60999b3a45.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar ChunkGenerator_1 = __webpack_require__(1);\r\n\tself.importScripts('public/scripts/vendor/three.min.js', 'public/scripts/vendor/simplex.js');\r\n\tvar ChunkGeneratorWorker = (function () {\r\n\t    function ChunkGeneratorWorker() {\r\n\t        var _this = this;\r\n\t        this.chunkGenerator = new ChunkGenerator_1.ChunkGenerator(1000, 10, null);\r\n\t        self.onmessage = function (event) {\r\n\t            switch (event.data.type) {\r\n\t                case \"generateChunks\":\r\n\t                    var chunks = _this.generateChunks(event.data.data);\r\n\t                    //postMessage(chunks);\r\n\t                    break;\r\n\t                case \"setGeneratorSettings\":\r\n\t                    var chunkSize = event.data.data.chunkSize;\r\n\t                    _this.chunkGenerator.chunkSize = chunkSize;\r\n\t            }\r\n\t        };\r\n\t    }\r\n\t    ChunkGeneratorWorker.prototype.generateChunks = function (chunkCoords) {\r\n\t        var chunks = new Array();\r\n\t        for (var _i = 0, chunkCoords_1 = chunkCoords; _i < chunkCoords_1.length; _i++) {\r\n\t            var chunkCoord = chunkCoords_1[_i];\r\n\t            var geometryData = this.chunkGenerator.generateChunkGeometryData(chunkCoord);\r\n\t            chunks.push({ coords: [chunkCoord.x, chunkCoord.y], geometryData: geometryData });\r\n\t        }\r\n\t        return chunks;\r\n\t    };\r\n\t    return ChunkGeneratorWorker;\r\n\t}());\r\n\tvar chunkGeneratorWorker = new ChunkGeneratorWorker();\r\n\tconsole.log(\"ChunkGenerator.worker loaded\");\r\n\t// Main thread will send terrain to be generated periodically\r\n\t// If new terrain is sent while the worker is still working on the last set of terrain, \r\n\t// send over what's completed and start working on the new set\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/// <reference path=\"../../../../typings/threejs/three.d.ts\"/>\r\n\t\"use strict\";\r\n\tvar Chunk_1 = __webpack_require__(2);\r\n\tvar ChunkGenerator = (function () {\r\n\t    function ChunkGenerator(chunkSize, segments, noiseGenerator) {\r\n\t        this.chunkSize = chunkSize;\r\n\t        this.segments = segments;\r\n\t        this.noiseGenerator = noiseGenerator;\r\n\t        this.groundMaterial = new THREE.MeshLambertMaterial();\r\n\t        //this.noiseGenerator = this.noiseGenerator ? this.noiseGenerator : new SimplexNoise();\r\n\t        /*\r\n\t        AddShaderChunks();\r\n\t\r\n\t        this.textureLoader = textureLoader || new THREE.TextureLoader();\r\n\t        this.noiseGenerator = new SimplexNoise();\r\n\t        this.mountainNoiseGenerator = new Noise();\r\n\t        this.mountainMultiplierNoiseGenerator = new SimplexNoise();\r\n\t        this.shaders =  { terrainLambert : THREE.ShaderLib[ 'lambert' ] };\r\n\t        this.segments = 5;\r\n\t        this.renderedSegments = 100;\r\n\t\r\n\t        let myProperties = {\r\n\t            lights: true,\r\n\t            fog: true,\r\n\t            transparent: true,\r\n\t            color: new THREE.Color(10, 150, 20),\r\n\t            map: null // this.grassTexture || THREE.ImageUtils.loadTexture( 'images/grass.png' )\r\n\t        };\r\n\t\r\n\t        let myUniforms = {\r\n\t            opacity: { type: \"f\", value: 0.4 },\r\n\t            color: new THREE.Vector3(255, 100, 0),\r\n\t            time: { value: 1.0 }\r\n\t        };\r\n\t\r\n\t        this.renderedGroundMaterial = this.terrainLambertMaterial(myProperties, myUniforms);\r\n\t    }\r\n\t\r\n\t    private terrainLambertMaterial(parameters, uniforms_) {\r\n\t\r\n\t        var material = new THREE.ShaderMaterial( {\r\n\t            vertexShader: GetTerrainVertexShader(),\r\n\t            fragmentShader: GetTerrainFragmentShader(),\r\n\t            uniforms: THREE.UniformsUtils.merge( [\r\n\t                uniforms_,\r\n\t                THREE.ShaderLib[ 'lambert' ].uniforms ] ),\r\n\t            lights: true\r\n\t        } );\r\n\t\r\n\t        material.setValues( parameters )\r\n\t\r\n\t        return material; */\r\n\t    }\r\n\t    /*public generateChunk(chunkCoords: THREE.Vector2): Chunk {\r\n\t        let realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\t\r\n\t        let material = new THREE.MeshLambertMaterial();\r\n\t\r\n\t        let geometry = new THREE.PlaneGeometry(this.chunkSize, this.chunkSize, this.segments, this.segments);\r\n\t        //geometry.translate(this.chunkSize / 2, this.chunkSize / 2, 0)\r\n\t\r\n\t        for ( var i = 0; i < geometry.vertices.length; i++ ) {\r\n\t            var vertex = geometry.vertices[i];\r\n\t            let noiseCoords = new THREE.Vector2((realCoords.x + vertex.x)/5000, (-realCoords.z + vertex.y)/5000);\r\n\t            vertex.z = this.noiseGenerator.noise(noiseCoords.x, noiseCoords.y) * 1000;\r\n\t        }\r\n\t        geometry.computeFaceNormals();\r\n\t        geometry.computeVertexNormals();\r\n\t\r\n\t        let mesh = new THREE.Mesh(geometry, material);\r\n\t        mesh.rotation.x = Math.PI / -2;\r\n\t        mesh.receiveShadow = true;\r\n\t        mesh.translateX(realCoords.x);\r\n\t        mesh.translateY(-realCoords.z);\r\n\t        return new Chunk(mesh);\r\n\t    } */\r\n\t    ChunkGenerator.prototype.generateChunk = function (chunkCoords) {\r\n\t        var realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\t        var geometry = new THREE.PlaneBufferGeometry(this.chunkSize, this.chunkSize, this.segments, this.segments);\r\n\t        var vertices = geometry.attributes.position.array;\r\n\t        for (var i = 2; i < vertices.length; i += 3) {\r\n\t            var noiseCoords = new THREE.Vector2((realCoords.x + vertices[i - 2]) / 5000, (-realCoords.z + vertices[i - 1]) / 5000);\r\n\t            vertices[i] += this.noiseGenerator.noise(noiseCoords.x, noiseCoords.y);\r\n\t        }\r\n\t        console.log(\"vertices[1] = \", vertices[1]);\r\n\t        geometry.computeVertexNormals();\r\n\t        geometry.rotateX(-Math.PI / 2);\r\n\t        geometry.translate(realCoords.x, 0, realCoords.z);\r\n\t        var mesh = new THREE.Mesh(geometry, this.groundMaterial);\r\n\t        mesh.receiveShadow = true;\r\n\t        return new Chunk_1.Chunk(mesh, chunkCoords);\r\n\t    };\r\n\t    ChunkGenerator.prototype.generateChunkGeometryData = function (chunkCoords) {\r\n\t        var geometryData = {};\r\n\t        var realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\t        var geometry = new THREE.PlaneBufferGeometry(this.chunkSize, this.chunkSize, this.segments, this.segments);\r\n\t        geometryData.vertices = geometry.attributes.position.array;\r\n\t        geometryData.normal = geometry.attributes.normal.array;\r\n\t        geometryData.uv = geometry.attributes.uv.array;\r\n\t        geometryData.indices = geometry.getIndex().array;\r\n\t        for (var i = 2; i < geometryData.vertices.length; i += 3) {\r\n\t            var noiseCoords = new THREE.Vector2((realCoords.x + geometryData.vertices[i - 2]) / 5000, (-realCoords.z + geometryData.vertices[i - 1]) / 5000);\r\n\t            geometryData.vertices[i] += this.noiseGenerator.noise(noiseCoords.x, +noiseCoords.y) * 1000;\r\n\t        }\r\n\t        return geometryData;\r\n\t    };\r\n\t    ChunkGenerator.prototype.generateChunkFromGeometryData = function (chunkCoords, geometryData) {\r\n\t        var realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\t        var geometry = new THREE.BufferGeometry();\r\n\t        geometry.setIndex(new THREE.BufferAttribute(geometryData.indices, 1));\r\n\t        geometry.addAttribute('position', new THREE.BufferAttribute(geometryData.vertices, 3));\r\n\t        geometry.addAttribute('normal', new THREE.BufferAttribute(geometryData.normal, 3));\r\n\t        geometry.addAttribute('uv', new THREE.BufferAttribute(geometryData.uvs, 2));\r\n\t        geometry.computeVertexNormals();\r\n\t        geometry.rotateX(-Math.PI / 2);\r\n\t        geometry.translate(realCoords.x, 0, realCoords.z);\r\n\t        var mesh = new THREE.Mesh(geometry, this.groundMaterial);\r\n\t        mesh.receiveShadow = true;\r\n\t        var chunk = new Chunk_1.Chunk(mesh, chunkCoords);\r\n\t        return chunk;\r\n\t    };\r\n\t    ChunkGenerator.prototype.setChunkSize = function (newChunkSize) {\r\n\t        this.chunkSize = newChunkSize;\r\n\t    };\r\n\t    ChunkGenerator.prototype.setSegments = function (newSegments) {\r\n\t        this.segments = newSegments;\r\n\t    };\r\n\t    ChunkGenerator.prototype.setNoiseGenerator = function (newNoise) {\r\n\t        this.noiseGenerator = newNoise;\r\n\t    };\r\n\t    ChunkGenerator.prototype.fastSigmoid = function (x) {\r\n\t        return x / (1 + Math.abs(x));\r\n\t    };\r\n\t    return ChunkGenerator;\r\n\t}());\r\n\texports.ChunkGenerator = ChunkGenerator;\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\tvar Chunk = (function () {\r\n\t    function Chunk(mesh, chunkCoordinates) {\r\n\t        this.mesh = mesh;\r\n\t        this.chunkCoordinates = chunkCoordinates;\r\n\t    }\r\n\t    return Chunk;\r\n\t}());\r\n\texports.Chunk = Chunk;\r\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** c6af69ab3b60999b3a45.worker.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c6af69ab3b60999b3a45\n **/","import {Chunk} from \"../models/Chunk\";\r\nimport {ChunkGenerator} from '../components/webgl-view/procedural-generation/ChunkGenerator';\r\n\r\ndeclare var self: any;\r\ndeclare var SimplexNoise: any;\r\n\r\nself.importScripts('public/scripts/vendor/three.min.js', 'public/scripts/vendor/simplex.js');\r\n\r\nclass ChunkGeneratorWorker {\r\n\tprivate chunkGenerator: ChunkGenerator;\r\n\r\n\tconstructor() {\r\n\t\tthis.chunkGenerator = new ChunkGenerator(1000, 10, null);\r\n\r\n\t\tself.onmessage = (event: MessageEvent) => {\r\n\t\t\tswitch(event.data.type) {\r\n\t\t\t\tcase \"generateChunks\":\r\n\t\t\t\t\tlet chunks = this.generateChunks(event.data.data);\r\n\t\t\t\t\t//postMessage(chunks);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"setGeneratorSettings\":\r\n\t\t\t\t\tlet chunkSize = event.data.data.chunkSize;\r\n\t\t\t\t\tthis.chunkGenerator.chunkSize = chunkSize;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic generateChunks(chunkCoords: THREE.Vector2[]): Array<{coords: Array<number>, geometryData: {vertices: Float32Array, normal: Float32Array, uvs: Float32Array, indices: Uint32Array}}> {\r\n\t\tlet chunks = new Array<{coords: Array<number>, geometryData: {vertices: Float32Array, normal: Float32Array, uvs: Float32Array, indices: Uint32Array}}>();\r\n\t\tfor(let chunkCoord of chunkCoords) {\r\n\t\t\tlet geometryData = this.chunkGenerator.generateChunkGeometryData(chunkCoord);\r\n\t\t\tchunks.push({coords: [chunkCoord.x, chunkCoord.y], geometryData: geometryData});\r\n\t\t}\r\n\t\treturn chunks;\r\n\t}\r\n}\r\nlet chunkGeneratorWorker: ChunkGeneratorWorker = new ChunkGeneratorWorker();\r\nconsole.log(\"ChunkGenerator.worker loaded\");\r\n\r\n// Main thread will send terrain to be generated periodically\r\n// If new terrain is sent while the worker is still working on the last set of terrain, \r\n// send over what's completed and start working on the new set\r\n\r\n\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/angular2-template-loader!./src/workers/ChunkGenerator.worker.ts\n **/","/// <reference path=\"../../../../typings/threejs/three.d.ts\"/>\r\n\r\ndeclare var SimplexNoise: any;\r\n\r\nimport {GetTerrainVertexShader} from \"../../shaders/TerrainShader_Vertex.glsl\"\r\nimport {GetTerrainFragmentShader} from \"../../shaders/TerrainShader_Fragment.glsl\"\r\nimport {AddShaderChunks} from \"../../shaders/ShaderChunks\";\r\nimport {Noise} from \"./Noise\";\r\nimport {Chunk} from \"../../../models/Chunk\";\r\n\r\nexport class ChunkGenerator {\r\n\tprivate mountainNoiseGenerator: Noise;\r\n\tprivate mountainMultiplierNoiseGenerator: any;\r\n\tprivate textureLoader: THREE.TextureLoader;\r\n\tprivate grassTexture: THREE.Texture;\r\n\tprivate shaders: any;\r\n\r\n\tprivate renderedGroundMaterial: THREE.Material;\r\n\tprivate renderedSegments: number;\r\n\r\n\tprivate groundMaterial: THREE.Material;\r\n\r\n\tconstructor(public chunkSize: number, public segments: number, private noiseGenerator: Noise) {\r\n\t\tthis.groundMaterial = new THREE.MeshLambertMaterial();\r\n\r\n\t\t//this.noiseGenerator = this.noiseGenerator ? this.noiseGenerator : new SimplexNoise();\r\n\r\n\t\t/*\r\n\t\tAddShaderChunks();\r\n\r\n\t\tthis.textureLoader = textureLoader || new THREE.TextureLoader();\r\n\t\tthis.noiseGenerator = new SimplexNoise();\r\n\t\tthis.mountainNoiseGenerator = new Noise();\r\n\t\tthis.mountainMultiplierNoiseGenerator = new SimplexNoise();\r\n\t\tthis.shaders =  { terrainLambert : THREE.ShaderLib[ 'lambert' ] };\r\n\t\tthis.segments = 5;\r\n\t\tthis.renderedSegments = 100;\r\n\r\n\t\tlet myProperties = {\r\n\t\t\tlights: true,\r\n\t\t\tfog: true,\r\n\t\t\ttransparent: true,\r\n\t\t\tcolor: new THREE.Color(10, 150, 20),\r\n\t\t\tmap: null // this.grassTexture || THREE.ImageUtils.loadTexture( 'images/grass.png' )\r\n\t\t};\r\n\r\n\t\tlet myUniforms = {\r\n\t\t\topacity: { type: \"f\", value: 0.4 },\r\n\t\t\tcolor: new THREE.Vector3(255, 100, 0),\r\n\t\t\ttime: { value: 1.0 }\r\n\t\t};\r\n\r\n\t\tthis.renderedGroundMaterial = this.terrainLambertMaterial(myProperties, myUniforms);\r\n\t}\r\n\r\n\tprivate terrainLambertMaterial(parameters, uniforms_) {\r\n\r\n\t\tvar material = new THREE.ShaderMaterial( {\r\n\t\t\tvertexShader: GetTerrainVertexShader(),\r\n\t\t\tfragmentShader: GetTerrainFragmentShader(),\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [ \r\n\t\t\t\tuniforms_, \r\n\t\t\t\tTHREE.ShaderLib[ 'lambert' ].uniforms ] ),\r\n\t\t\tlights: true\r\n\t\t} );\r\n\r\n\t\tmaterial.setValues( parameters )\r\n\r\n\t\treturn material; */\r\n\t}\r\n\r\n\tprivate tempVertex: number;\r\n\r\n\t/*public generateChunk(chunkCoords: THREE.Vector2): Chunk {\r\n\t\tlet realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\r\n\t\tlet material = new THREE.MeshLambertMaterial();\r\n\r\n\t\tlet geometry = new THREE.PlaneGeometry(this.chunkSize, this.chunkSize, this.segments, this.segments);\r\n\t\t//geometry.translate(this.chunkSize / 2, this.chunkSize / 2, 0)\r\n\r\n\t\tfor ( var i = 0; i < geometry.vertices.length; i++ ) {\r\n\t\t\tvar vertex = geometry.vertices[i];\r\n\t\t\tlet noiseCoords = new THREE.Vector2((realCoords.x + vertex.x)/5000, (-realCoords.z + vertex.y)/5000);\r\n\t\t\tvertex.z = this.noiseGenerator.noise(noiseCoords.x, noiseCoords.y) * 1000;\r\n\t\t}\r\n\t\tgeometry.computeFaceNormals();\r\n\t\tgeometry.computeVertexNormals();\r\n\r\n\t\tlet mesh = new THREE.Mesh(geometry, material);\r\n\t\tmesh.rotation.x = Math.PI / -2;\r\n\t\tmesh.receiveShadow = true;\r\n\t\tmesh.translateX(realCoords.x);\r\n\t\tmesh.translateY(-realCoords.z);\r\n\t\treturn new Chunk(mesh);\r\n\t} */\r\n\r\n\tpublic generateChunk(chunkCoords: THREE.Vector2): Chunk {\r\n\t\tlet realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\t\tlet geometry = new THREE.PlaneBufferGeometry(this.chunkSize, this.chunkSize, this.segments, this.segments);\r\n\t\tlet vertices = geometry.attributes.position.array;\r\n\t\tfor(let i = 2; i < vertices.length; i += 3) {\r\n\t\t\tlet noiseCoords = new THREE.Vector2((realCoords.x + vertices[i - 2])/5000, (-realCoords.z + vertices[i - 1])/5000);\r\n\t\t\tvertices[i] += this.noiseGenerator.noise(noiseCoords.x, noiseCoords.y);\r\n\t\t}\r\n\t\tconsole.log(\"vertices[1] = \", vertices[1]);\r\n\t\tgeometry.computeVertexNormals();\r\n\r\n\t\tgeometry.rotateX( -Math.PI/2);\r\n\t\tgeometry.translate(realCoords.x, 0, realCoords.z);\r\n\t\tlet mesh = new THREE.Mesh(geometry, this.groundMaterial);\r\n\t\tmesh.receiveShadow = true;\r\n\t\treturn new Chunk(mesh, chunkCoords);\r\n\t}\r\n\r\n\tpublic generateChunkGeometryData(chunkCoords: THREE.Vector2): {vertices: Float32Array, normal: Float32Array, uvs: Float32Array, indices: Uint32Array} {\r\n\t\tlet geometryData: any = {};\r\n\r\n\t\tlet realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\t\tlet geometry = new THREE.PlaneBufferGeometry(this.chunkSize, this.chunkSize, this.segments, this.segments);\r\n\t\tgeometryData.vertices = geometry.attributes.position.array;\r\n\t\tgeometryData.normal = geometry.attributes.normal.array;\r\n\t\tgeometryData.uv = geometry.attributes.uv.array;\r\n\t\tgeometryData.indices = geometry.getIndex().array;\r\n\t\tfor(let i = 2; i < geometryData.vertices.length; i += 3) {\r\n\t\t\tlet noiseCoords = new THREE.Vector2((realCoords.x + geometryData.vertices[i - 2])/5000, (-realCoords.z + geometryData.vertices[i - 1])/5000);\r\n\t\t\tgeometryData.vertices[i] += this.noiseGenerator.noise(noiseCoords.x, + noiseCoords.y) * 1000;\r\n\t\t}\r\n\t\treturn geometryData;\r\n\t}\r\n\r\n\tpublic generateChunkFromGeometryData(chunkCoords: THREE.Vector2, geometryData: {vertices: Float32Array, normal: Float32Array, uvs: Float32Array, indices: Uint32Array}): Chunk {\r\n\t\t\tlet realCoords = new THREE.Vector3(chunkCoords.x * this.chunkSize, 0, chunkCoords.y * this.chunkSize);\r\n\r\n\t\t\tlet geometry = new THREE.BufferGeometry(); \r\n\t\t\tgeometry.setIndex( new THREE.BufferAttribute( geometryData.indices, 1 ) );\r\n\t\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute(geometryData.vertices, 3));\r\n\t\t\tgeometry.addAttribute('normal', new THREE.BufferAttribute(geometryData.normal, 3));\r\n\t\t\tgeometry.addAttribute('uv', new THREE.BufferAttribute(geometryData.uvs, 2));\r\n\t\t\t\r\n\r\n\t\t\tgeometry.computeVertexNormals();\r\n\t\t\tgeometry.rotateX( -Math.PI/2);\r\n\t\t\tgeometry.translate(realCoords.x, 0, realCoords.z);\r\n\r\n\t\t\tlet mesh = new THREE.Mesh(geometry, this.groundMaterial);\r\n\t\t\tmesh.receiveShadow = true;\r\n\r\n\t\t\tlet chunk = new Chunk(mesh, chunkCoords);\r\n\t\t\treturn chunk;\r\n\t}\r\n\r\n\tpublic setChunkSize(newChunkSize: number) {\r\n\t\tthis.chunkSize = newChunkSize;\r\n\t}\r\n\r\n\tpublic setSegments(newSegments: number) {\r\n\t\tthis.segments = newSegments;\r\n\t}\r\n\r\n\tpublic setNoiseGenerator(newNoise: Noise) {\r\n\t\tthis.noiseGenerator = newNoise;\r\n\t}\r\n\r\n\tprivate fastSigmoid(x: number): number {\r\n\t\treturn x / (1 + Math.abs(x));\r\n\t}\r\n\r\n\t/*private worleyNoise(xCoordinate: number, yCoordinate: number, scale: number) {\r\n\t\tfunction cos(angle) {\r\n\t\t\t\tif (angle.length) return angle.map(cos);\r\n\t\t\t\treturn Math.cos(angle);\r\n\t\t}\r\n\t\tfunction fract(x) {\r\n\t\t\t\tif (x.length) return x.map(fract);\r\n\t\t\t\treturn x - Math.floor(x);\r\n\t\t}\r\n\t\tfunction floor(x) {\r\n\t\t\t\tif (x.length) return x.map(floor);\r\n\t\t\t\treturn Math.floor(x);\r\n\t\t}\r\n\t\tfunction vec2(x, y) {\r\n\t\t\t\tif (x == null) x = 0;\r\n\t\t\t\tif (y == null) y = x;\r\n\t\t\t\treturn [x, y]\r\n\t\t}\r\n\t\tvec2.add = function anonymous(out,a,b) {\r\n\t\t\tout[0] = a[0] + b[0];\r\n\t\t\tout[1] = a[1] + b[1]\r\n\t\t\treturn out;\r\n\t\t}\r\n\t\tfunction length(x) {\r\n\t\t\t\tvar sum = 0;\r\n\t\t\t\tfor (var i = 0; i < x.length; i++) {\r\n\t\t\t\t\t\tsum += x[i]*x[i];\r\n\t\t\t\t}\r\n\t\t\t\treturn Math.sqrt(sum);\r\n\t\t}\r\n\t\tfunction r (n) {\r\n\t\t\t\treturn fract(cos(n * 89.42) * 343.42);\r\n\t\t};\r\n\t\tfunction r_vec2 (n) {\r\n\t\t\t\treturn [r(n[0] * 23.62 - 300.0 + n[1] * 34.35), r(n[0] * 45.13 + 256.0 + n[1] * 38.89)];\r\n\t\t};\r\n\t\tfunction worley (n, s) {\r\n\t\t\t\tvar dis = 2.0;\r\n\t\t\t\tfor (var x = -1; x <= 1; x++) {\r\n\t\t\t\t\tfor (var y = -1; y <= 1; y++) {\r\n\t\t\t\t\t\tvar p = vec2.add([], floor([n[0] / s, n[1] / s]), [x, y]);\r\n\t\t\t\t\t\tvar d = length([r_vec2(p)[0] + x - fract([n[0] / s, n[1] / s])[0], r_vec2(p)[1] + y - fract([n[0] / s, n[1] / s])[1]]);\r\n\t\t\t\t\t\tif (dis > d) {\r\n\t\t\t\t\t\tdis = d;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t};\r\n\t\t\t\t};\r\n\t\t\t\treturn 1.0 - dis;\r\n\t\t};\r\n\t\treturn worley([xCoordinate, yCoordinate], scale)\r\n\t} */\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/angular2-template-loader!./src/components/webgl-view/procedural-generation/ChunkGenerator.ts\n **/","export class Chunk {\r\n\tconstructor(public mesh: THREE.Mesh, \r\n\t\tpublic chunkCoordinates: THREE.Vector2) {}\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/angular2-template-loader!./src/models/Chunk.ts\n **/"],"sourceRoot":""}